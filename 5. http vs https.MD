## HTTP와 HTTPS의 기본개념을 한번 알아볼까요?

---

<BR>

### HTTP란?

<BR>

- HTTP는 하이퍼 텍스트 전송 프로토콜의(Hypertext Transfer Protocol)의 약자입니다. `서로 다른 시스템들 사이에서 통신을 주고받게 해주는 가장 기초적인 프로토콜`인데요. 여러분이 웹 서핑을 할 때 서버에서 여러분의 브라우저로 데이터를 전송해 주는 용도로 가장 많이 사용됩니다. 그리고 인터넷의 초기에 모든 웹사이트에서 기본적으로 사용되었던 프로토콜이기도 하죠.

<Br>

### ✔ HTTPS란?

- HTTPS는 하이퍼 텍스트 전송 프로토콜 보안(Hypertext Transfer Protocol Secure)의 약자입니다. 일반 HTTP 프로토콜의 문제점은 서버에서부터 브라우저로 전송되는 정보가 암호화되지 않는다는 것이었는데요. 이 말은 즉, 데이터가 쉽게 도난당할 수 있다는 것이었습니다. HTTPS 프로토콜은 `SSL(보안 소켓 계층)`을 사용함으로써 이 문제를 해결했습니다. `SSL은 서버와 브라우저 사이에 안전하게 암호화된 연결을 만들 수 있게 도와주고, 서버 브라우저가 민감한 정보를 주고받을 때 이것이 도난당하는 것을 막아줍니다.` HTTP vs HTTPS의 차이 그 첫번째는 `‘보안성’`에 있다는 것이지요.

- TCP/IP 443번 포트 사용

- 소켓 통신에서 일반 텍스트를 이용하는 대신에, SSL이나 TLS 프로토콜을 통해 세션 데이터를 암호화 → 데이터의 적절한 보호 보장

- 고려해야하는 부분

  - 암호화/복호화의 과정이 필요하기 때문에 HTTP보다 속도가 느림(오늘날에는 거의 차이를 못느낄 정도)

  - 인증서를 발급하고 유지하기 위한 추가 비용 발생

<BR>

### 왜, HTTPS는 보안이 뛰어나다고 말하는 걸까요?

<br>

<img src="https://blog.wishket.com/wp-content/uploads/2020/02/03-3.png">

<br>

‘HTTP vs HTTPS 차이’는 바로 `SSL 인증서`입니다. 사실 HTTPS는 쉽게 말해서 HTTP 프로토콜에 보안 기능을 추가한 것이라고 말할 수 있는데요. 보안 기능은 생각보다 매우 중요합니다. 특히 신용카드 정보나 비밀번호 등 사용자들의 민감한 정보들을 다루는 웹사이트에서라면 더욱 그렇죠.

`SSL 인증서는 사용자가 사이트에 제공하는 정보를 암호화하는데, 쉽게 말해서 데이터를 암호로 바꾼다고 생각하면 쉽습니다. 이렇게 전송된 데이터는 중간에서 누군가 훔쳐 낸다고 하더라도 데이터가 암호화되어있기 때문에 해독할 수 없습니다. 그 외에도 HTTPS는 TLS(전송 계층 보안) 프로토콜을 통해서도 보안을 유지합니다.` TSL은 데이터 무결성을 제공하기 때문에 데이터가 전송 중에 수정되거나 손상되는 것을 방지하고, 사용자가 자신이 의도하는 웹사이트와 통신하고 있음을 입증하는 인증 기능도 제공하고 있습니다.

<br>

### HTTPS는 보안 말고 또 다른 장점은 없나요?

---

<br>

<img src="https://blog.wishket.com/wp-content/uploads/2020/02/04-4.jpg">

<br>

HTTP vs HTTPS 차이 그 두번째는 `SEO 품질`에 있습니다. 만약 여러분의 웹사이트에 전자상거래 기능도 없고 방문자들의 민감한 정보를 다루지도 않는다면, HTTPS로 전환할 필요성이 크게 느껴지지 않을 겁니다. 하지만 HTTPS의 장점은 보안상 우위에만 있는 것이 아닙니다. `사실 HTTPS로 전환하게 되면 검색엔진 최적화(SEO)에 있어서도 큰 혜택을 볼 수 있는데요.` 이는 앞서 말했듯이 구글이 HTTPS 웹사이트에 가산점을 주는 이유 때문이기도 하지만, 사용자들이 결국에는 가장 안전하다고 생각하는 사이트를 더 많이 방문하기 때문이기도 합니다.

<BR>

📌 보안

- 보안 단계를 거치기 때문에 서버 부하 증가로 인한 처리 속도 이슈는 없는가?

  - 최근에 네트워크 장비와 서버 장비 성능의 폭발적 증가에 따라, 체감하는 속도 저하는 거의 발생하지 않음

📌 검색 우선순위
<BR>

- 그럼 개인정보를 사용하지 않는 사이트는 굳이 https를 적용하지 않아도 되는 것 아닌가?

  - 우리가 대표적으로 사용하는 검색 포털 사이트인 구글, 네이버, 다음 모두에서 검색 엔진 최적화(SEO: Search Engine Optimization)을 통해 https를 상위 노출하고 있음
    동일한 키워드의 페이지 중에서 https 기반 사이트가 우선 순위로 노출

<br>

<img src="https://blog.wishket.com/wp-content/uploads/2020/02/06-1.png">

<br>

또한 `가속화된 모바일 페이지(AMP, Accelerated Mobile Pages)를 만들고 싶을 때도 HTTPS 프로토콜을 사용해야만 합니다.` 여기서 AMP란 모바일 기기에서 훨씬 빠르게 콘텐츠를 로딩 하기 위한 방법으로 구글이 만든 것입니다. AMP는 HTML에서 불필요한 부분을 없앤 것이라고 볼 수 있습니다. 구글의 SERP(검색 결과 페이지)를 보면 스마트폰과 태블릿의 사용자들이 모바일에서 사용하기 편하도록 AMP 콘텐츠들이 두드러져 보이는 것을 볼 수 있습니다
모바일 친화적인 웹사이트를 만드는 것과 모바일 검색순위 및 지역에 SEO를 증가시키는 것이 점점 더 중요해지고 있는 요즘, HTTP를 HTTPS로 전환하는 것이 필수라고 볼 수 있습니다.

<br>

### ✔ HTTPS로 전환하려면 무엇을 가장 먼저 고려해야 할까요?

<br>

HTTP에서 HTTPS로 전환하게 되면 좋은 점들도 많이 있지만 실제로 그렇게 하는 과정에서는 여전히 몇 가지 잠재적인 문제들도 있습니다. 다음에서 HTTPS로 전환할 때 알아둬야 하는 팁들을 준비해 두었으니, SEO와 관련된 문제에 부딪히지 않기를 원하신다면 잘 살펴보시기 바랍니다.

<br>

<img src="https://blog.wishket.com/wp-content/uploads/2020/02/08-1.png">

<br>

### ✔ SSL 적용 방식

<BR>

- SSL 암호화 통신은 비대칭키 방식(암호화에 사용할 키를 교환)

- 데이터 통신은 대칭키 방식

<br>

<img src="https://velog.velcdn.com/images%2Fswhan9404%2Fpost%2F7bee2ed7-3c25-4f5b-8e76-99e10ebc6182%2Fimage-20210818082210208.png">

<br>

1. 핸드 셰이킹
2. 데이터 전송
3. 세션 종료

<br>

- SSL 적용은 `핸드 셰이킹 단계`에서 발생이 된다.

  - SSL 핸드셰이킹 : 443 포트를 이용하여 서로의 상태를 파악하는 TCP 기반의 프로토콜

  - TCP 기반이기 때문에 SSL 핸드세이크 전에 TCP 3-way 핸드셰이크 또한 수행

<br>
  
✔ 핸드 셰이킹 순서

<Br>

1. Client hello : 클라이언트가 서버에게 연락

<Br>

- ex) 브라우저 검색창에 도메인을 입력하는 것
- 이때 클라이언트는 자신의 브라우저가 지원할 수 있는 암호화 방식(Cipher Suite)을 먼저 제시합니다. 그리고 랜덤 데이터를 생성하여 추가로 전송
- `세션 아이디`: 이미 SSL 핸드쉐이킹을 했다면 비용과 시간을 절약하기 위해서 기존의 세션을 재활용하게 되는데 이때 사용할 연결에 대한 식별자를 서버 측으로 전송

<br>

1. Server hello : 서버가 클라이언트에게 연락

<br>

- 서버는 클라이언트가 제시한 암호화 방식 중 하나를 선정하여 알려줍니다.
- 또한, 서버 자신의 인증서를 전달합니다. 이 인증서에는 서버의 공개 키가 포함되어 있습니다. ( public key )
- 클라이언트와 마찬가지로 서버 측에서 생성한 랜덤 데이터 또한 전달

<Br>

3. Client key exchange

<br>

- 인증서가 자신이 신용있다고 판단한 CA로부터 서명된 것인지 확인(또한 날짜가 유효한지, 그리고 인증서가 접속하려는 사이트와 관련되어 있는지 확인)

- 클라이언트는 미리 주고받은 자신과 서버의 랜덤 데이터를 참고하여 서버와 암호화 통신을 할 때 사용할 키(랜덤 대칭 암호화 키)를 생성한 후 서버에게 전달합니다.

- 이때 키는 서버로부터 받은 공개키로 암호화되어 보내집니다.

<Br>

4. Finished

<br>

- 마지막으로 핸드셰이크 과정이 정상적으로 마무리되면, 클라이언트와 서버 모두 “finished” 메시지를 보냅니다.

<Br>

5. 이후 전송단계로 넘어가서 클라이언트가 생성한 키를 이용하여 암호화된 데이터를 주고받게 됩니다.

<br>

✔ 핸드 쉐이킹 이후 데이터 전송 과정

1. 클라이언트의 암호화한 데이터 전송

<Br>

- public key를 사용해서 랜덤 대칭 암호화키를 비롯한 URL, http 데이터들을 암호화해서 전송

<br>

2. 웹서버의 복호화

<br>

- private key를 이용해서 랜덤대칭 암호화키와 URL. http를 복호화

<BR>

3. 웹서버의 암호화 데이터 전송

<Br>

- 요청받은 URL에 대한 응답을 웹브라우저로부터 받은 랜덤 대칭 암호화키를 이용하여 암호화해서 브라우저로 전송

<Br>

4. 클라이언트의 복호화

<br>
대칭 암호키를 이용해서 http 데이터와 html 문서를 복호화하고 화면에 뿌려줌

<br>

<img src="https://velog.velcdn.com/images%2Fswhan9404%2Fpost%2F9ee41ec8-7ba7-4e83-b375-9282f8bf5a29%2Fimage-20210818115748767.png">

<BR>

### ✔ [ HTTPS의 동작 과정 ]

<BR>

- 공개키 방식(PKI, Public Key Infrastructure)
- 공개키는 두 개의 키를 갖게 되며, A키로 암호화하면 B키로 복호화가 가능하며, 반대로 B키로 암호화하면 A키로 복호화 가능
- 여기서 두 개의 키 중 하나는 공개키(public key)가 되며, 하나는 비공개키(private key)가 됨

- 비공개키는 소유자(private한 사용자)가 가지고 있게 되며, 공개키는 소유자와 타인에게 공개되는 키

<bR>

HTTPS는 대칭키 암호화와 비대칭키 암호화를 모두 사용하여 빠른 연산 속도와 안정성을 모두 얻고 있다.

HTTPS 연결 과정(Hand-Shaking)에서는 먼저 서버와 클라이언트 간에 세션키를 교환한다. 여기서 세션키는 주고 받는 데이터를 암호화하기 위해 사용되는 대칭키이며, 데이터 간의 교환에는 빠른 연산 속도가 필요하므로 세션키는 대칭키로 만들어진다.

문제는 이 세션키를 클라이언트와 서버가 어떻게 교환할 것이냐 인데, 이 과정에서 비대칭키가 사용된다.

즉, 처음 연결을 성립하여 안전하게 세션키를 공유하는 과정에서 비대칭키가 사용되는 것이고, 이후에 데이터를 교환하는 과정에서 빠른 연산 속도를 위해 대칭키가 사용되는 것이다.

<BR>

<IMG SRC="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fu6wAy%2Fbtq2kraEHVI%2FIP57zdWPLzNDQSZhIEvsV1%2Fimg.png">

<BR>

암호학을 공부하는게 아니니 공개키 알고리즘을 간단하게만 소개하겠다.

암호화, 복호화시킬 수 있는 서로 다른 키 2개가 존재하는데 이 두 개의 키는 서로 1번 키로 암호화하면 반드시 2번키로만 복호화할 수 있고 2번 키로 암호화하면 반드시 1번키로만 복호화할 수 있는 룰이 있는 것이다.그 중에서 하나 키는 모두에게 공개하는 공개키(1번 키)로 만들어서 공개키 저장소에 등록해놓는다.

서버는 서버만 알 수 있는 개인키(2번 키)를 소유하고 있으면 된다.그러면 1번키로 암호화된 http 요청, 즉 HTTPS 프로토콜을 사용한 요청이 온다면 서버는 개인키(2번 키)를 이용하여 1번키로 암호화된 문장을 해독하게 된다.

서버는 요청이 무엇인지 알게되고 요청에 맞는 응답을 다시 개인키(2번 키)로 암호화해서 요청한 클라이언트에게 보내주게 된다.

그리고 응답을 받은 클라이언트는 공개키(1번 키)를 이용해서 개인키(2번 키) 암호화된 HTTPS 응답을 해독하고 사용하는 시나리오다. (\* 공개키 암호화 방식에 대한 이해를 위한 설명일 뿐 더 정확한 HTTPS 연결 과정은 아래에 따로 정리 했습니다.)

HTTPS를 지원하는 서버에 요청(Request)을 하려면 공개키가 필요하다는 것을 알 수 있다.

그러면 그 공개키는 공개키 저장소에 있다는 것은 알겠는데 어떻게 공개키 저장소에서 가져올까?

추가적으로 공개키는 누구나 얻을 수 있고 공개키를 알면 서버가 주는 데이터(Response)는 알 수 있는데 보안상에 의미가 있을까?

보안상의 의미는 없다. 대신 얻을 수 있는 이점은 해당 서버로부터 온 응답임을 확신할 수 있다.

왜? 공개키로 해독이 가능했으니까 반드시 해당 서버의 개인키로 암호화했다는 것을 보장하기 때문이다.

아까 의문을 가졌던 것을 다시 생각해보자.

<BR>

### 🤷‍♀️ 공개키가 공개키 저장소에 있는데 어떻게 가져올 수 있을까?

<bR>

HTTPS 통신 흐름에 대해서 자세히 들여다보면 알 수 있다.

일단 공개키 저장소라고 부르던 곳이 원래 명칭은 CA(Certificate Authority)다. CA는 민간기업이지만 아무나 운영할 수 없고 신뢰성이 검증된 기업만 CA를 운영할 수 있다.

<BR>

1. 먼저 애플리케이션 서버(A)를 만드는 기업은 HTTPS를 적용하기 위해서 공개키와 개인키를 만듭니다.

2. 그 다음에 신뢰할 수 있는 CA 기업을 선택하고 그 기업에 내 공개키를 관리해달라고 계약하고 돈을 지불합니다.

3. 계약을 완료한 CA 기업은 또 CA 기업만의 공개키와 개인키가 있습니다.CA 기업은 CA기업의 이름과 A서버의 공개키, 공개키의 암호화 방법 등의 정보를 담은 인증서를 만들고, 해당 인증서를 CA 기업의 개인키로 암호화해서 A서버에게 제공합니다.

4. A서버는 암호화된 인증서를 갖게 되었습니다. 이제 A서버는 A서버의 공개키로 암호화된 HTTPS 요청이 아닌 요청(Request)이 오면 이 암호화된 인증서를 클라이언트에게 줍니다.

5. 이제 클라이언트 입장에서, 예를 들어 A서버로 index.html 파일을 달라고 요청했습니다. 그러면 HTTPS 요청이 아니기 때문에 CA기업이 A서버의 정보를 CA 기업의 개인키로 암호화한 인증서를 받게되겠지요.

6. 여기서 중요합니다. `세계적으로 신뢰할 수 있는 CA 기업의 공개키는 브라우저가 이미 알고 있습니다!`

7. 브라우저가 CA 기업 리스트를 쭉 탐색하면서 인증서에 적혀있는 CA기업 이름이 같으면 해당 CA기업의 공개키를 이미 알고 있는 브라우저는 해독할 수 있겠죠? 그러면 해독해서 A서버의 공개키를 얻었습니다.

8. 그러면 A서버와 통신할 때는 A서버의 공개키로 암호화해서 Request를 날리게 되겠죠.

이런 구성입니다만, HTTPS를 지원한다고 해서 무조건 안전한 것은 아닙니다.

왜냐하면 신뢰할 수 있는 CA 기업이 아니라 자체적으로 인증서를 발급할 수도 있고, 신뢰할 수 없는 CA 기업을 통해서 인증서를 발급받을 수도 있기 때문입니다.

그렇게 되면 브라우저에서는 https지만 "주의 요함", "안전하지 않은 사이트"등의 알림을 주게됩니다.

<Br>

### SSL 인증서

<br>

✔ SSL 인증서는 클라이언트와 서버간의 통신을 제3자가 보증해주는 전자화된 문서

<br>

<img src="https://velog.velcdn.com/images%2Fswhan9404%2Fpost%2F3aee5da6-caa9-49d6-9e23-68f1cb09078e%2Fimage-20210818223039378.png">

<br>

- 언제 검증하는가?

  - 클라이언트가 서버에 접속한 직후에 서버는 클라이언트에게 이 인증서 정보를 전달하게 됩니다.

  - 클라이언트는 이 인증서 정보가 신뢰할 수 있는 것인지를 검증 한 후에 다음 절차를 수행하게 됩니다.

<Br>

- SSL 인증서의 역할

  - 클라이언트가 접속한 서버가 신뢰할 수 있는 서버임을 보장

  - SSL 통신에 사용할 공개키를 클라이언트에게 제공

<Br>

- 인증서의 내용

  - 서비스의 정보 (인증서를 발급한 CA, 서비스의 도메인 등등)

    - 클라이언트가 접속한 서버가 신뢰할 수 있는 서버임을 보장하는 역할에 사용

    <BR>

  - 서버 측 공개키 (공개키의 내용, 공개키의 암호화 방법)
    - 서비스의 도메인, 공개키와 같은 정보는 서비스가 CA로부터 인증서를 구입할 때 제출하고, CA에 의해 암호화해서 저장(CA는 CA 공개키를 이용해서 서버가 제출한 인증서를 암호화)

<BR>

### CA

<BR>

✔ 인증서를 통해 클라이언트가 접속한 서버가 클라이언트가 의도한 서버가 맞는지를 보장하는 역할

✔ CA(Certificate authority) 혹은 Root Certificate

<bR>

- 브라우저의 CA 리스트

  - 브라우저는 내부적으로 CA 리스트를 미리 파악하고 있습니다.

  - 즉, 브라우저가 미리 파악하고 있는 CA의 리스트에 포함되어야만 공인된 CA가 될 수 있는 것

- 확인 결과 서버를 통해서 다운받은 인증서가 내장된 CA 리스트에 포함되어 있다면 해당 CA의 공개키를 이용해서 인증서를 복호화

  - CA의 공개키를 이용해서 인증서를 복호화 할 수 있다는 것은 이 인증서가 CA의 비공개키에 의해서 암호화 된 것을 의미

<BR>

### Let’s Encrypt란?

<BR>

Let’s Encrypt는 SSL 인증서를 무료로 발급해주는 CA(Certificate Authorities)입니다. 여러 글로벌 기업의 후원을 받고 있으며 모질라(Mozilla) 재단에서 ‘신뢰할 수 있는 인증 기관(Trusted CA)’ 으로 인증도 받았습니다. 따라서 베리사인(VeriSign)이나 코모도(Comodo)와 같은 유명 인증 업체와 같은 신뢰도를 가지며 SSL 암호화 기술 방식과 동작도 정확히 동일합니다. 단지 다른 것은 사이트의 인증에 문제가 있어 최종 웹사이트 방문자가 피해를 입었을 경우 배상 여부만 차이가 있을 뿐입니다. 여기를 누르면 추가자거인 SSL과 CA에 대한 쉽고 간략하게 설명한 글을 볼 수 있습니다.

<BR>

### Certbot

<BR>
Let’s Encrypt의 SSL인증서는 ACME(Automatic Certificate Management Environment) 프로토콜을 준수하는 프로그램을 이용해 발급을 받을 수 있는데 Let’s Encyrpt는 Certbot 사용을 권장하고 있습니다. 여기를 방문하면 ACME를 지원하는 기타 프로그램 목록을 볼 수 있습니다. 참고로 2016년 5월까지 Certbot은 letsencrypt 나 letsencrypt-auto로 불렸습니다.

<BR>

Certbot을 시스템 관리자가 서버에서 실행하는 프로그램입니다. 시스템 관리자는 Certbot을 통해 인증서를 직접 요청할 수 있습니다. 다양한 웹서버와 운영체제에 적합한 패키지 역시 배포하고 있습니다. 이 페이지에서 자신의 환경에 맞는 패키지를 검색하고 설치하는 방법을 쉽게 찾을 수 있습니다. Certbot에 대한 문서는 여기를 참고하세요.

출처 `https://mangkyu.tistory.com/98 [MangKyu's Diary:티스토리]` <br>
출처 `https://post.naver.com/viewer/postView.nhn?volumeNo=16561296&memberNo=1834` <BR>
출처 `https://hyeran-story.tistory.com/159` <BR>
출철 `https://velog.io/@swhan9404/HTTP%EC%99%80-HTTPS-%EC%B0%A8%EC%9D%B4-%EA%B5%AC%EB%B6%84%ED%95%98%EA%B8%B0`
