## HTTP 특성

---

<BR>

- HTTP는 인터넷 상에서 데이터를 주고 받기 위한 서버/클라이언트 모델을 따르는 프로토콜입니다.
- 클라이언트가 서버에게 요청을 보내면 서버는 응답을 보냄으로써, 데이터를 교환합니다.
- HTTP는 비연결성 및 무상태성 이라는 특징을 가지고 있습니다. HTTP는 요청에 대한 응답을 처리하게 되면 연결을 끊어 버립니다. 따라서 클라이언트에 대한 이전의 상태 정보 및 현재 통신의 상태가 남아있지 않습니다.

- 서버가 다수의 클라이언트와 연결을 계속 유지한다면, 이에 따른 자원 낭비가 심해집니다. 비연결성 및 무상태성의 특징을 가진다면 불필요한 자원 낭비를 줄일 수 있다는 장점이 있습니다.

- 그러나 서버는 클라이언트를 식별할 수 없다는 단점 또한 존재합니다. 로그인을 하더라도 다음 요청에서는 해당 클라이언트를 기억하지 못해, 또 로그인을 해야하는 문제가 발생합니다. 브라우저에서 새로고침을 누를 때마다 로그인을 해야하는 상황, 상상이 되시나요? 😱😱

### 😎 기억하는 척 하기 위해 사용되는 세션과 토큰

<BR>

이 문제를 해결하기 위한 대표적인 도구 두 가지가 바로 `세션(Session)`과 `토큰(Token)`입니다.

유저가 로그인을 시도할 때 서버상에서 일치하는 유저 정보를 찾았다면 `인증(Authentication)` 확인의 표시로 세션이나 토큰을 발급/전달해줍니다.

그럼 웹 브라우저 측에서 해당 세션/토큰 정보를 받아 간직하고 있다가 새로운 request를 보낼 때마다 `인가(Authorization)`를 위해 해당 세션/토큰을 함께 보냅니다.

그런데 세션과 토큰 모두 존재 목적은 거의 같지만 `차이점`은 존재합니다.

그 중 가장 큰 차이점은 `세션`은 `데이터베이스 서버`에 저장된다는 것,

`토큰`은 `클라이언트 측`에서만 저장한다는 점입니다.

<BR>

## 2. Cookie

---

<BR>

✔ 쿠키란 클라이언트가 어떠한 웹사이트를 방문할 경우, 그 사이트가 사용하고 있는 서버를 통해 클라이언트의 브라우저에 설치되는 작은 기록 정보 파일을 일컫습니다.

<BR>

```JS
MockHttpServletResponse:
           Status = 200
          Headers = [Set-Cookie:"userName=kevin", "password=abc123"]
```

<BR>

- 서버는 클라이언트의 로그인 요청에 대한 응답을 작성할 때, 클라이언트 측에 저장하고 싶은 정보를 응답 헤더의 Set-Cookie에 담습니다.

  - 쿠키는 Key-Value 형식의 문자열입니다.

<BR>

```JS
MockHttpServletRequest:
      HTTP Method = GET
      Request URI = /user/my/edit
          Headers = [Cookie:"userName=kevin"; "password=abc123"]
```

<BR>

- 이후 해당 클라이언트는 요청을 보낼 때마다, 매번 저장된 쿠키를 요청 헤더의 Cookie에 담아 보냅니다.

- 서버는 쿠키에 담긴 정보를 바탕으로 해당 요청의 클라이언트가 누군지 식별할 수 있습니다.

<BR>

### 🤦‍♂️ 단점

<bR>

- 보안에 취약합니다.
  - 요청 시 쿠키의 값을 그대로 보냅니다.
  - 유출 및 조작 당할 위험이 존재합니다.
- 쿠키에는 용량 제한이 있어 많은 정보를 담을 수 없습니다.
- 웹 브라우저마다 쿠키에 대한 지원 형태가 다르기 때문에 브라우저간 공유가 불가능합니다.
- 쿠키의 사이즈가 커질수록 네트워크에 부하가 심해집니다.

<BR>

## Cookie & Session 기반 인증

---

<BR>

<IMG SRC="https://doozi316.github.io/assets/images/WEB32/1.png">

<BR>

✔ 쿠키를 통해 클라이언트 로그인 상태를 유지시킬 수 있었지만, `가장 큰 단점은 쿠키가 유출 및 조작 당할 위험`이 존재한다는 것입니다. `개인정보를 HTTP로 주고 받는 것은 위험`합니다.

- 세션은 비밀번호 등 `클라이언트의 인증 정보를 쿠키가 아닌 서버 측에 저장하고 관리`합니다.

<BR>

```JS
HTTP/1.1 200
Set-Cookie: JSESSIONID=FDB5E30BF20045E8A9AAFC788383680C;
```

<BR>

- 서버는 클라이언트의 로그인 요청에 대한 응답을 작성할 때, 인증 정보는 서버에 저장하고 클라이언트 식별자인 JSESSIONID를 쿠키에 담습니다.

- 이후 클라이언트는 요청을 보낼 때마다, JSESSIONID 쿠키를 함께 보냅니다.

- 서버는 JSESSIONID 유효성을 판별해 클라이언트를 식별합니다.

<BR>

### 📌 쿠키 vs 세션

<BR>

세션은 HTTP의 stateless 속성을 보완한다는 점에서 쿠키와 자주 비교되곤 한다.

쿠키의 유형에는 영구 쿠키와 세션 쿠키가 있어 만료시기가 각각 다르지만 세션은 대부분의 경우 브라우저 종료 시 만료된다.

쿠키와 세션의 가장 큰 차이는 `저장 위치`이다.

`쿠키`는 `클라이언트`에 저장되고, `세션`은 `서버`에 저장된다.

그러나 서로 반대 되는 개념이 아니라 세션 id를 쿠키에 담아서 통신한다는 점에서 세션은 쿠키를 사용하는 방식이라고 볼 수 있다.

쿠키에 로그인에 대한 정보를 담는다면 클라이언트에 노출 되어 위험하기 때문에 서버에 저장하는 방식으로 세션을 사용한다.

<BR>

### 📝장단점

<BR>

- 쿠키를 포함한 요청이 외부에 노출되더라도 세션 ID 자체는 유의미한 개인정보를 담고 있지 않습니다.

- 그러나 해커가 이를 중간에 탈취하여 클라이언트인척 위장할 수 있다는 한계가 존재합니다.
- 각 사용자마다 고유한 세션 ID가 발급되기 때문에, 요청이 들어올 때마다 회원정보를 확인할 필요가 없습니다. 그렇기 때문에 Session ID에 매칭된 회원정보를 바로 확인할 수 있고, 이를 토대로 해당 회원과 관련된 정보를 DB에서 확인하기에 용이하다.
- 서버에서 세션 저장소를 사용하므로 요청이 많아지면 서버에 부하가 심해집니다.

- 이것 또한 세션의 한계 중 하난데, 세션의 경우 쿠키에 Session ID를 저장해 정보를 지속적으로 확인하지만, 브라우저 의외의 환경(이를테면 앱)에서는 쿠키활용이 안된다. 하지만 jwt의 경우 다양한 플랫폼에서의 활용이 가능하다.

- 세션 데이터가 서버의 메모리에 저장되므로, 확장 시 모든 서버가 접근할 수 있도록 별도의 중앙 세션 관리 시스템이 필요하다.

- 중앙 세션 관리 시스템이 없으면, 시스템 확장에 어려움이 생긴다.
- 중앙 세션 관리 시스템이 장애가 일어나면, 시스템 전체가 문제가 생긴다.
- 규모 확장이 필요없는 소규모 프로그램 작성에서는 세션 기반 인증 방식을 사용해도 상관 없을 것이다.

<BR>

## JWT 기반 인증

---

<BR>

<IMG SRC="https://doozi316.github.io/assets/images/WEB32/2.png">

<BR>

- JWT(JSON Web Token)란 인증에 필요한 정보들을 암호화시킨 토큰을 의미합니다. JWT 기반 인증은 쿠키/세션 방식과 유사하게 JWT 토큰(Access Token)을 HTTP 헤더에 실어 서버가 클라이언트를 식별합니다.

<BR>

#### 📌JWT 구조

<bR>

<IMG SRC= "https://tecoble.techcourse.co.kr/static/50692d28ac56af0c30039d81eaebeb01/244f0/2021-05-22-jwt-total.png">

<BR>

- JWT는 .을 구분자로 나누어지는 세 가지 문자열의 조합입니다. 실제 디코딩된 JWT는 다음과 같은 구조를 지닙니다.

### ✔ Header

<BR>

<IMG SRC="https://tecoble.techcourse.co.kr/static/e794bd3bc3eca832350bd730318c5ebb/f7886/2021-05-22-jwt-header.png">

<BR>

- Header는 alg과 typ는 각각 정보를 암호화할 해싱 알고리즘 및 토큰의 타입을 지정합니다.

<BR>

### ✔ Payload

<BR>

<IMG SRC="https://tecoble.techcourse.co.kr/static/52fc7e21e5ba27aa1634ca26836785ce/1e7a9/2021-05-22-jwt-payload.png">

<BR>

- Payload는 토큰에 담을 정보를 지니고 있습니다. 주로 클라이언트의 고유 ID 값 및 유효 기간 등이 포함되는 영역입니다. key-value 형식으로 이루어진 한 쌍의 정보를 Claim이라고 칭합니다.

<BR>

### ✔ Signature

<BR>

<IMG SRC="https://tecoble.techcourse.co.kr/static/445b9916a7dd4f17b9682ef353457484/c4bf7/2021-05-22-jwt-signature.png">

<BR>

- Signature는 인코딩된 Header와 Payload를 더한 뒤 비밀키로 해싱하여 생성합니다. Header와 Payload는 단순히 인코딩된 값이기 때문에 제 3자가 복호화 및 조작할 수 있지만, Signature는 `서버 측에서 관리하는 비밀키`가 유출되지 않는 이상 복호화할 수 없습니다. 따라서 Signature는 토큰의 위변조 여부를 확인하는데 사용됩니다.

<BR>

### JWT 보안 위험

---

<BR>

✔ JWT는 자체 내에 정보를 가지고 있기 때문에 클라이언트가 해독해 정보를 볼 수 있다. 하지만 받는 자가 secret 키를 알고 있어야만 수정이 가능하다.

<bR>

📌 작동 원리

1. A가 B에게 JWT를 보내려한다.
2. A, B 둘다 암호화한 secret 키를 알고 있다.
3. C는 secret 키를 알지 못하지만 A, B 사이의 JWT를 몰래 변경하려한다.
4. A는 이를 방지하기 위해 signature 부분에 (payload+secret key)를 특정 알고리즘으로 해시화해 추가했다.
5. C가 이 JWT를 변경하려해도 secret key를 몰라 멋대로 변경할 수 없다.
6. B는 C가 변경한 JWT를 받으면 서명이 다르기 때문에 받지 않는다.

### ✔ 인증 과정

<BR>

```JS
{
	Authorization: <type> <access-token>
}
```

<BR>

1. 클라이언트 로그인 요청이 들어오면, 서버는 검증 후 클라이언트 고유 ID 등의 정보를 Payload에 담습니다.

2. 암호화할 비밀키를 사용해 Access Token(JWT)을 발급합니다.
3. 클라이언트는 전달받은 토큰을 저장해두고, 서버에 요청할 때 마다 토큰을 요청 헤더 Authorization에 포함시켜 함께 전달합니다.
4. 서버는 토큰의 Signature를 비밀키로 복호화한 다음, 위변조 여부 및 유효 기간 등을 확인합니다.
5. 유효한 토큰이라면 요청에 응답합니다.

✔ 클라이언트 측에 JWT를 저장하는 경우 사용하는 플랫폼에 따라 다름

- 브라우저 : 로컬 저장소
- IOS : KeyChain
- Android : SharedPreferences

<bR>

### 🤷‍♂️ JWT가 데이터를 보호하는 방법

<BR>

✔ JWT는 데이터를 보호하지 않는다.

- JWT는 데이터를 숨기거나 모호하게 보호하지 않는다.
- JWT(Header, Payload, Signature)를 생성하는 프로세스는 데이터를 암호화하지 않고 데이터만 인코딩 및 해시하는 것을 볼 수 있다.
- JWT의 목적은 데이터가 인증된 소스에서 생성되었음을 증명하는 것이다
- 그렇다면 JWT를 얻을 수 있는 Man-in-the-middle attack이 있는 경우 사용자 정보를 디코딩 할 수 있는가?
  - 그렇다 때문에 항상 어플리케이션에 HTTPS 암호화가 있는지 확인하라

<BR>

### ✨ 장점

<bR>

- JWT를 이용하면 따로 서버의 메모리에 저장 공간을 확보할 필요가 없다. 서버가 토큰을 한번 클라이언트에게 보내주면 클라이언트는 토큰을 보관하고 있다가(가장 쉬운 방법은 localstorage에 저장하는 것이다) 요청을 보낼때마다 헤더에 토큰을 실어보내면 된다. 쿠키를 사용할 수 없는(쿠키는 웹브라우저에서 사용할수 있는 기능이다!) 모바일 어플리케이션에는 JWT를 사용한 인증방식이 최적이다.

- Header와 Payload를 가지고 Signature를 생성하므로 데이터 위변조를 막을 수 있습니다.
- 인증 정보에 대한 별도의 저장소가 필요없습니다.
- JWT는 토큰에 대한 기본 정보와 전달할 정보 및 토큰이 검증됬음을 증명하는 서명 등 필요한 모든 정보를 자체적으로 지니고 있습니다.
- 클라이언트 인증 정보를 저장하는 세션과 다르게, 서버는 무상태가 됩니다.
- 확장성이 우수합니다.
- 토큰 기반으로 다른 로그인 시스템에 접근 및 권한 공유가 가능합니다.
- OAuth의 경우 Facebook, Google 등 소셜 계정을 이용하여 다른 웹서비스에서도 로그인을 할 수 있습니다.
- 모바일 어플리케이션 환경에서도 잘 동작합니다.

<BR>

### 🤦‍♂️ 단점

- 쿠키/세션과 다르게 JWT는 토큰의 길이가 길어, 인증 요청이 많아질수록 네트워크 부하가 심해집니다.

- Payload 자체는 암호화되지 않기 때문에 유저의 중요한 정보는 담을 수 없습니다.
- 토큰을 탈취당하면 대처하기 어렵습니다.
- 토큰은 한 번 발급되면 유효기간이 만료될 때 까지 계속 사용이 가능하기 때문입니다.
- 특정 사용자의 접속을 강제로 만료하기 어렵지만, 쿠키/세션 기반 인증은 서버 쪽에서 쉽게 세션을 삭제할 수 있습니다.

- JWT는 HTTP를 통해서 전송하기 때문에 페이로드의 크기가 클수록 데이터 전송에 있어서 비용이 커진다. JWT는 유효기간을 따로 정하지 않는 이상 소멸되지 않기 때문에 장기간 방치시 해킹의 위험이 커진다.

- 또한 JWT를 localstorage에 보관한다면 XSS공격에 취약해진다. (XSS는 외부의 해커가 우리의 프 로그램에 특정 javascript 코드를 심어서 localstorage에 접근하는 공격이다.)

- 보통 httpOnly가 설정되서 브라우저만 접근 가능한 쿠키에 토큰을 실어보내서 XSS 공격을 막는다.

<BR>

### 🔥 보안 전략

<bR>

- JWT 사용시 상기한 단점들을 극복하기 위해 다양한 전략을 채택할 수 있습니다. `각각의 전략은 장단점이 상이하기 때문에, 서비스의 특성을 고려하여 보안 수준을 높일지 사용자의 편의성을 높일지 결정해야 합니다.`

<bR>

### ✔ AccessToken 사용

<bR>

사용자가 로그인을 할 때 클라이언트에게 AccessToken을 발급합니다. 서버는 AccessToken을 데이터베이스나 파일등에 저장 할 필요 없이 메모리상에서 미리 정의 된 비밀키를 이용해 비교하는 것 만으로 인증을 처리하기 때문에 `추가적인 I/O 작업이 필요가 없습니다.` 반면에 그런 이유로 `서버는 특정 사용자의 접속을 강제로 만료시키기 어렵습니다.` 일반적으로 클라이언트는 스스로의 저장 공간에서 토큰을 삭제하는 방법을 사용해 사용자의 접근을 막습니다.

<BR>

### ✔ 짧은 만료 기한 설정

<BR>

JWT는 토큰의 만료 시간을 설정 할 수 있는데, 이를 30분 내의 짧은 기간으로 설정하는 경우에 대한 장/단점을 알아보겠습니다.

<BR>

📌 장점

<BR>

- 기기나 AccessToken이 탈취되더라도 빠르게 만료됩니다.

<BR>

📌 단점

<BR>

- 사용자는 자주 로그인을 해야 합니다. 한 사용자가 오랫동안 상주하는 서비스라면 서비스를 이용하는 도중에 갑자기 인증이 만료되어 로그인창이 뜨는 경우를 볼 수 있습니다.

<BR>

### ✔ 긴 만료 시간을 설정

<BR>

- 짧은 만료 시간을 설정했을 때의 단점을 상쇄하기 위해 2주에서 한달 정도로 만료 시간을 길게 주면 어떨까요? 당연하게도 위에서 살펴본 장, 단점과 정반대의 상황이 벌어집니다.

<BR>

📌 장점

<BR>

사용자가 로그인을 자주 할 필요가 없습니다.

<BR>

📌 단점

<BR>

기기나 AccessToken이 탈취되면 오랫동안 제약 없이 사용이 가능합니다.

<BR>

### ✔ Sliding Session

<BR>

보안성과 편의성 모두를 잡을 수는 없을까를 고민하다가 나온 것이 Sliding Sessions 전략입니다. 이 전략은 `세션을 지속적으로 이용하는 유저에게 자동으로 만료 기한을 늘려주는 방법`입니다.

구현 방법은 다양합니다만 주로 유효한 AccessToken을 가진 클라이언트의 요청에 대해 서버가 새로운 AccessToken을 발급해주는 방법을 사용합니다. 매 요청마다 새로운 토큰을 내려주는 것도 가능하지만, 글을 작성하다가 인증이 만료되는 참담한 경우를 막기 위해 `글 작성을 시작할 때 발급해준다거나, 쇼핑몰에서 장바구니에 아이템을 담는 경우에 발급해주는 등의 전략을 사용하는 것도 괜찮은 방법`입니다. 또 `클라이언트가 토큰의 iat(토큰 발급 시간)속성을 참조해서 갱신 요청을 하는 방법`도 있습니다.

이 방법을 활용하면 AccessToken만을 이용해 인증을 처리할 때 있었던 단점을 보완해 줄 수 있습니다.

<BR>

<BR>

📌 장점

<BR>

- 사용자가 로그인을 자주 할 필요가 없습니다.
- 글을 작성하거나 결제를 하는 등의 세션 유지가 필요한 순간에 세션이 만료되는 문제를 방지 할 수 있습니다.

<BR>

📌 단점

<BR>

- 접속이 주로 단발성으로 이루어지는 서비스의 경우 Sliding Sessions 전략의 효과가 크지 않습니다.
- 긴 만료 시간을 갖는 AccessToken을 사용하는 경우 로그인을 전혀 하지 않아도 되는 경우가 발생합니다.

<BR>

### ✔ AccessToken과 RefreshToken을 사용

<BR>

사용자가 로그인을 할 때에 `AccessToken`과 함께 그에 비해 `긴 만료 시간을 갖는 RefreshToken`을 클라이언트에 함께 발급합니다. 주로 `AccessToken은 30분 내외`, `RefreshToken은 2주에서 한달 정도`의 만료 기간을 부여합니다.

클라이언트는 `AccessToken이 만료`되었다는 오류를 받으면 따로 저장해두었던 `RefreshToken`을 이용하여 `AccessToken의 재발급을 요청`합니다. 서버는 `유효한 RefreshToken`으로 요청이 들어오면 `새로운 AccessToken을 발급`하고, `만료된 RefreshToken`으로 요청이 들어오면 `오류를 반환`해, 사용자에게 `로그인을 요구`합니다.

`AccessToken`은 서버에 따로 저장해 둘 필요가 없지만, `RefreshToken의 경우 서버의 stroage에 따로 저장`해서 이후 검증에 활용해야 합니다. `그러므로 RefreshToken을 이용한다는 것은 추가적인 I/O 작업이 필요하다는 의미`이며, 이는 `I/O 작업이 필요없는 빠른 인증 처리를 장점으로 내세우는 JWT의 스펙에 포함되지 않는 부가적인 기술`입니다.

`RefreshToken`은 탈취되어서는 곤란하므로 `클라이언트는 보안이 유지되는 공간`에 이를 저장해두어야 합니다.

`RefreshToken`은 `서버에서 따로 저장을 하고 있기 때문에 강제로 토큰을 만료`시키는 것이 가능합니다.

<BR>

<BR>

📌 장점

<BR>

- 짧은 만료 기간을 사용 할 수 있기 때문에 AccessToken이 탈취되더라도 제한된 기간만 접근이 가능합니다.
- 사용자가 로그인을 자주 할 필요가 없습니다.
- RefreshToken에 대한 만료를 강제로 설정 할 수 있습니다.
  <BR>

📌 단점

<BR>

- 클라이언트는 AccessToken의 만료에 대한 연장 요청을 구현해야 합니다.
- 인증 만료 기간의 자동 연장이 불가능합니다.
- 서버에 별도의 storage를 만들어야 합니다.

<BR>

### ✨ 결론

<BR>

일반적인 웹 서비스처럼 cookie등을 이용해 세션 관리를 하는 방식을 사용할 수 없는 stateless한 REST API등은 토큰 방식의 보안을 이용 할 수 밖에 없습니다. stateless하기 때문에 매 요청에 대한 인증을 거쳐야 하는데, 이는 데이터베이스 등으로부터 토큰을 얻어오는 추가적인 I/O 작업이 불가피하고 이는 성능의 하락으로 이어집니다. 이를 해결해주기 위한 솔루션이 바로 JWT입니다.

JWT는 이런 장점과 함께 위에서 살펴봤듯이 여러가지 문제점들이 존재합니다. 토큰의 탈취에 대한 취약성, 서버의 클라이언트 제어 불가, 빈번한 로그인 요청 등의 문제에 대한 해결 방법은 RefreshToken이나 Sliding Sessions 등의 전략을 도입하는 것입니다. 하지만 이러한 전략들 역시 추가적인 IO 작업을 위한 성능 감소나, 편의를 위해 보안이 취약해지는 상황등이 발생할 가능성이 있습니다.

서비스가 결제가 필요한 보안에 민감한 컨텐츠를 다루고 있다면 비밀번호 한번 더 입력하는 것이 크게 문제가 되지 않습니다. 반면, 게시물에 글을 작성할때마다 비밀번호를 입력해야 한다면 사용자들은 매우 귀찮아 할 것입니다. 결국 모든 것을 얻을 수는 없습니다. 서비스마다 가진 고유한 특성을 고려해 보안 수준을 높일지, 사용자 편의성을 높일지를 결정해야 합니다.

<bR>

## Session vs JWT

---

### ✔ 차이점 1. 사이즈

<BR>

### 📌세션 < 토큰

<BR>

세션을 사용시 주고받는 session id의 크기는 매우 작습니다.

반면 (JWT기준) 토큰은 같은 데이터를 담고 있어도 그에 비해 크기가 큽니다.

사실 이 차이점을 신경쓰고 쓰는 사람은 많지 않은 것 같습니다만..

<IMG SRC="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fbuhw0I%2Fbtq16yOC7mi%2FVEMGprJKWQ2P0kFqK6aK4K%2Fimg.png">

<BR>

### ✔ 차이점 2. 안전성

<BR>

### 📌 세션

<BR>

- 세션은 `서버측에서 저장/관리`하기 때문에 상대적으로 온전한 상태를 유지하기 `유리`합니다.

- 하지만 `여전히 공격의 위험`이 있기에 `유효기간`, `HttpOnly`, `Secure` 옵션 등을 주어 쿠키에 저장합니다.

<BR>

### 📌 토큰

<BR>

- 반대로 토큰은 웹 브라우저 측 (local storage, 혹은 쿠키 등)에 저장되기 때문에 `공격에 노출될 가능성`이 더 큽니다.

- 이런 경우를 대비해 토큰에는 `민감한 정보를 담지 않습니다`.

- 그리고 `유효기간을 짧게 설정`해 공격에 노출될 수 있는 시간을 최소화합니다.

- 하지만 짧은 주기로 토큰이 무효화되면 서비스 사용자는 계속 로그인을 해줘야 하는 번거로움이 있기 때문에 애초에 로그인(인증)시 `refresh token`이라는 것을 추가적으로 발급합니다.

- `refresh token`은 좀 더 긴 유효기간을 가졌으며 최대한 안전한 곳에 저장됩니다.

- 기존의 토큰이 만료되거나 변질되면 `refresh token`을 통해 `토큰을 재발급`합니다.

<BR>

### 📌차이점 3. 확장성

<BR>

- 최근 대부분의 웹 서비스가 `토큰 방식`을 선택하게 된 이유가 바로 `확장성`에 있습니다.

- `세션`은 서버에 저장되기 때문에 한꺼번에 다중 접속자가 발생한다면 과부하가 걸릴 수 있습니다.

- 그럼 과부하를 덜어주기 위해 서버를 여러 대를 두면 되겠죠?

- 하지만 또 서버가 여러대라면 세션을 쓰기가 복잡해집니다.

<BR>

### 📌 서버 분산 / 클러스터 환경에서 드러나는 결정적인 차이

<BR>

- 요즘 많은 서비스들은 서버 과부하 부담을 줄이기 위해 여러 서버를 두고 서비스를 운영합니다.

- 그리고 앞서 언급했듯 HTTP는 `stateless`, `connectionless` 하기 때문에 request마다 내가 접속한 서버가 달라질 수도 있습니다!!

- 이렇게 되어 버리면 `session 정보가 없는 다른 서버`에 접속할 때마다 계속 로그인해줘야 합니다.

<BR>

<IMG SRC ="https://blog.kakaocdn.net/dn/lG4ij/btq126ZJI7R/8hq8jedzuFepCBBKyPOT10/img.gif">

<BR>

물론 이러한 세션의 단점을 해결하기 위해 `sticky session`, `session clustering`과 같은 방안이 나오기도 했습니다만 또 이 방안들도 감안해야 할 처리 비용이 발생하기 때문에\*
애초에 이런 걱정 없이 쓸 수 있는 토큰이 인기가 많은 게 아닌가 싶습니다.

- sticky session은 처음 지정받은 서버만 사용할 수 있기 때문에 해당 서버가 터지거나 과부하가 걸려도 어찌할 도리가 없습니다.

- session clustering은 모든 서버마다 세션을 복사해줘야 하기 때문에 상당한 메모리를 요구할 뿐 아니라 매 로그인마다 오버헤드가 크게 발생합니다.

<BR>
 
물론 세션용 서버를 따로 두고 쓰는 방법도 있습니다.

<bR>

하지만 만일을 대비하여 서버를 복제해두어야 합니다.

애초에 토큰방식을 사용한다면 추가 서버 없이 인증/인가를 처리할 수 있습니다.

<BR>

✔ JWT 인증이 필요한 이유는?

- 웹 사이트만 있는 것이 아니라 거기에 많은 플랫폼이 있기 때문이다.
- 세션과 잘 작동하는 웹사이트가 있다고 가정하자, 언젠가는 모바일(네이티브 앱) 시스템을 구현하고 현재 웹앱과 동일한 DB를 사용하려고 한다.
- 이러한 종류에는 쿠키가 없기때문에 세션 기반 인증으로 Nativa App을 사용하는 사용자를 인증할 수 없다.
- 네이티브 앱을 지원하는 또다른 백엔드를 구축하기도, 네이티브 앱 사용자를 위한 인증 모듈을 작성하기도 난감하기 때문에 토큰 기반 인증을 사용하는 것이다.
- 최상의 인증 방법은 없다

`자료 출처 https://tecoble.techcourse.co.kr/post/2021-05-22-cookie-session-jwt/`<BR>
`자료 출처 https://doozi316.github.io/web/2021/03/08/WEB32/`<BR>
`자료 출처 https://fierycoding.tistory.com/69` <BR>
`자료 출처 https://blog.ull.im/engineering/2019/02/07/jwt-strategy.html` <BR>
