## 도커를 사용하는 이유

---

<br>

### 🤷‍♀️ 도커 없이도 배포/운영하고 있는데, 우린 아무 불편을 느끼지 못합니다. 왜 도커를 써야 하죠?

<br>

### 📌 운영하면서 만들어지는 눈송이 서버들(Snowflake Servers)

<br>

서버 운영을 오래 해 본 사람이라도, 처음 들어가는 서버에서는 마음 먹은 대로 문제를 해결하기가 어렵습니다.

이는 서버를 다루는 기술과는 별개로, 각 서버마다 운영 기록이 다르기 때문입니다.

똑같은 일을 하는 두 서버가 있다 해도, A 서버는 한 달 전에 구성했고 B 서버는 이제 막 구성했다면, 운영체제부터 컴파일러, 설치된 패키지까지 완벽하게 같기는 쉽지 않습니다.그리고 이러한 차이점들이 장애를 일으키고 말죠.

`A 서버는 잘 되는데 B 서버는 왜 죽었지?`와 같은 일(혹은 그 반대)이 벌어지는 겁니다.

이렇게 서로 모양이 다른 서버들이 존재하는 상황을 `눈송이 서버Snowflakes Server`이라고도 합니다. 모든 눈송이의 모양이 다르듯, 서버들도 서로 다른 모습이라는 말이죠.

<br>

A 서버와 B 서버에 이미지매직ImageMagick이라는 도구를 설치한다고 가정해봅시다.

A 서버는 지난 달에 서버를 구성하면서 이미지매직을 설치했고, B 서버는 이제 막 구성한 상황이니 새로 이미지매직을 설치했습니다.

그리고 웹 서비스를 업데이트하여 각 서버에 배포합니다. A 서버에서 장애가 발생했습니다.

이 상황에서 장애 발생 원인은 대략 다음과 같이 추측할 수 있습니다.

<br>

- 웹 서비스에서 이미지매직 최신 버전에 새로 추가된 기능을 사용했다.
- 웹 서비스의 업데이트 부분 코드에 버그가 있다
- 이미지매직의 버전이 다르다

- 이미지매직이 의존하는 라이브러리의 버전이 다르다

<br>

장애 원인을 빨리 찾으려면 A 서버를 잘 아는 사람이 필요할텐데 마침 A 서버를 구성했던 사람이 팀을 옮겼거나 퇴사해서 옆에 없습니다.

B 서버를 구성한 작업자는 A 서버가 구성되고 운영된 모든 과정을 파악하려고 애를 쓸 겁니다. 그래야 B 서버와의 차이점을 알아낼 수 있으니까요.

여기서는 두 서버 간 구성 시점이 한 달 밖에 차이나지 않지만, 막상 현업에서는 몇 년씩 차이나는 경우도 있습니다.

처음엔 각 서버 사이의 차이점이 눈송이 하나 만큼 작을지 모르지만, 서버를 오래 운영하다보면 점점 커져서 나중엔 집을 삼키는 거대한 눈덩이가 되어 있을 겁니다.

<br>

### ✨ 배포(혹은 실행)하는 시점과 상관 없이 서버의 내용을 똑같게 할 수 있는 도커

<br>

<img src= "https://d2uleea4buiacg.cloudfront.net/files/fda/fda75bc98a7a5f0dcd4a546e5454f15a7ef42972be5220b58045509b428a39d0.m.png">

<br>

예를 들어 앞서 살펴본 앤서블의 플레이북으로 서버에 이미지매직을 설치한다고 합시다. 작업자가 1년 전에 이 플레이북으로 서버 A를 구성했고, 오늘 서버 B를 구성한다면, 두 서버에 대해 이미지매직이 설치된 시점은 1년의 차이가 발생합니다.

하지만 도커에서는 앞서 살펴본 도커 파일로 이미지를 만들어 두면, 서버가 구성되는 시점이 이미지를 만든 시점으로 고정됩니다. 이 이미지를 사용해 1년 전에 A 서버에 컨테이너를 배포하고, 오늘 B 서버에 컨테이너를 배포한다고 해도, 두 컨테이너 모두 이미지매직이 설치된 시점은 같습니다.

이것이 바로 도커가 여느 서버 구성 도구와 가장 다른 부분입니다. 다른 도구들은 모두 도구를 실행하는 시점에 서버의 상태가 결정되는 데 비해, 도커는 작업자가 그 시점을 미리 정해둘 수 있습니다. 덕분에 서버를 항상 똑같은 상태로 만들 수 있는 것이죠.

<Br>

    도커 파일 == 서버 운영 기록
    도커 이미지 == 도커 파일 + 실행 시점
    도커 컨테이너 == 도커 이미지 + 환경 변수

<Br>

### 도커를 사용하는 이유 1. 애플리케이션을 구동하기 위한 환경을 제공

<Br>

`동일하게 작성된 애플리케이션이라도 실행하는 환경이 달라지면 정상적으로 작동하지 않을 수 있습니다.`

만약, Java 11에서만 지원하는 기능을 사용해서 애플리케이션을 작성했는데 다른 컴퓨터에 Java 11을 위한 JVM이 없다면 동작하지 않게됩니다. (똑같이 쳤는데 왜 안되지?...)

도커는 작성된 애플케이션 뿐 아니라 `당시 개발 환경까지 그대로 담아서` 사용 서버에서 실행해주기 때문에 `현재 환경에 상관없이 작성된 그대로 애플리케이션을 실행할 수 있습니다.`

<Br>

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fbr8apd%2FbtrCkpa98gP%2Fbi5wuCFm1LDraxDFqCVCsK%2Fimg.png">

<br>

개발 환경에서 Java 11로 개발한 애플리케이션을 이미지라는 형태로 저장하고 도커 서버에 업로드 -> 실행 환경에서 해당 이미지를 다운로드 -> 도커 컨테이너에서 바로 실행

<br>

### 도커를 사용하는 이유 2. 확장과 축소에 유리

<br>

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbTOA2i%2FbtrCjWOhKga%2F5j01U0WZyGDZOeip6Pnxd1%2Fimg.png">

<br>

`컨테이너는 하나의 운영체제(OS)를 공유하며 독립된 환경을 제공합니다.`

만약 서버 방문자가 늘어 애플리케이션을 증설해야한다면 컨테이너를 이용해 동일한 애플리케이션을 늘릴 수 있습니다.

위 예시는 1G 크기의 애플리케이션 4개와 10G의 OS로 구성되어 14G 크기의 환경이 구동되는 모습입니다.

<br>

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbtLhIt%2FbtrCiP28wag%2F81ts9H0FFc0iRQK9TiI8Ck%2Fimg.png">

<Br>

만약 컨테이너가 아닌 가상머신(VM)을 이용한다면 상대적으로 무거운 OS가 증설할 애플리케이션 개수만큼 필요해 총 44G의 크기의 애플리케이션이 실행되게 됩니다.

이렇게 컨테이너를 활용하면 더 가볍고 빠르게 애플리케이션을 증가, 감소 시킬 수 있게됩니다.

또한, 동일한 애플리케이션이 아닌 각기 다른 서비스를 세분화해서 서로 독립된 환경에서 동작하는 MSA(Micro Service Architecture)를 실현할 수 있습니다.

<Br>

### 도커를 사용하는 이유 3. 배포 과정의 단순화

<br>

위의 이유와 보태어 제 개인적인 경험으로는 먼저, 서버의 구축과 시작 및 설정이 매우 간단하고 빨랐습니다.
AWS 인스턴스 하나를 먼저 생성하면 Ubuntu OS 밖에 없는 깡통인데(다른 OS도 선택 가능합니다), 가장먼저 하는 일이 Dokcer를 설치하는 일이었고 그 후 이미지를 다운받고 컨테이너를 실행시키는 몇개의 명령어만 입력하면 금방 작업이 완료 되었던 기억이 나네요.

<br>

### VM(Virtual Machine)과 컨테이너(Container)의 차이

<br>

앞서 설명했던 컨테이너의 등장 이전에 사용하던 VM과는 어떤 차이가 있는 것이고, 왜 도커에 열광할까요 ?

우리가 다른 운영체제를 사용하기 위해서 VM(Virtual Machine)을 한번쯤은 사용해보신 경험이 있으실 겁니다. (사용해보신 경험이 없으셔도 무관합니다.)

우리가 기존 사용하고 있는 운영체제(Window를 사용한다고 가정) 이외에 다른 운영체제(Linux 라고 가정)를 사용하고 싶을 때 주로 VM을 사용해 OS 전체를 가상화 하는 방식으로 사용했습니다.

즉 기존 OS(Window) 와 다른 OS(Linux)는 완전히 독립적으로 존재하는 것이죠. 그런데 다른OS(Linux)를 사용하기 위해서는 기존 OS(Window)를 이용해야 했기 때문에 속도가 엄청나게 느려지고, 독립적인 OS기 때문에 설치해야할 용량 또한 큽니다.

<br>

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FdJN045%2FbtqGbOTevZ7%2Fdok3jbKoIv8wwZbSJ2Nf9k%2Fimg.jpg">

<br>

하지만, 컨테이너(Container)는 VM을 사용하지 않고 도커 엔진(Docker Engine)을 사용하여 동작합니다.

더이상 가상화 하지 않고 개선된 프로세스 격리 방법의 등장이죠.

별도의 OS 사용이 필요하지 않게 되어, 성능적인 개선과 동시에 메모리 용량 또한 작아집니다. ( 운영체제를 통째로 깔아야 하는 가상머신에 비하면 용량이 매우 작아지는 것이죠 )

도커는 `명령수행에 Host의 OS를 사용`하고 Host OS와 Container OS의 차이나는 부분만 컨테이너 내에 패키징 합니다.

저는 이부분에서 도커가 VM에 비해 '가볍다' 라고 하는 것으로 이해했습니다. VM은 해당 영역에 또다른 OS를 설치하고 그 OS를 통해 명령을 수행해야 하기 때문에 한 컴퓨터에서 여러개의 OS가 동작해야 하는것으로 보아야겠지요.

하지만 Docker는 기존의 OS를 사용하기 때문에 VM에 비해 가볍지 않나 생각합니다.

도커에서 컨테이너와 동시에 중요한 개념이 하나 더 등장하는데 이미지라는 것입니다.

도커엔진 위의 컨테이너에 이미지라는 실행에 필요한 파일과 설정값들을 담아 주는 것이죠.

즉, 이미지는 컨테이너를 실행하기 위한 모든 정보를 가지고 있기 때문에 이것저것 설치할 필요가 없이 새로운 서버가 생기면 미리 만들어 놓은 이미지만을 다운받아 컨테이너를 생성하면 되는 것입니다.

<Br>

### 가상화와 비교했을 때 컨테이너 기술의 장점

<br>

- 가벼운 가상화 기술

  - 가상화와 비교하면 컨테이너는 OS 없이 프로세스와 파일 시스템을 분리하는 형태이기 때문에 크기가 작고 가볍습니다.

  - 또한 가상화를 위한 하드웨어 에뮬레이트 (emulate) 단계 없이, 분리된 공간을 만들기 때문에 오버 헤드가 줄어 듭니다.

<Br>

- 높은 집적도

  - 여러 개의 컨테이너를 만들어서 실행 중이라고 해도 OS는 하나이므로, 가상머신에 비해 고밀도화가 가능합니다.

  - 또한 컨테이너에서는 실행되는 프로세스를 위한 메모리만 필요하기 때문에 낮은 사양의 환경에서 더욱 활용도가 높아집니다.

<br>

- 작은 이미지 크기

  - 가상화 기술은 가상머신마다 OS (게스트 OS)가 필요합니다. 따라서 VM의 실행에 필요한 이미지 파일 (이하 VM 이미지) 은 애플케이션과 실행에 필요한 라이브러리 그리고 게스트 OS가 포함되어 있습니다.

  - 반면 컨테이너는 호스트 OS를 사용하여 시작합니다. 가상머신과는 달리 게스트 OS는 포함하지 않기 때문에 VM 이미지와 보다 파일 크기가 작아 이동성이 우수합니다.

<br>

- 이동성 ( PORTABILITY)

  - 컨테이너는 이동성이 높기 때문에 개발자가 자신의 PC에서 만든 컨테이너를 그대로 퍼블릭 클라우드에 가져가 실행할 수 있습니다.

  - 이로 인해 대량의 마이크로 서비스의 빠르고 효율적인 배치 및 서비스 단위로 유연한 확장이 가능하며, 마이크로 서비스를 통해 얻는 효과를 극대화 할 수 있습니다.

<br>

- 빠른 시작과 종료 시간

  - 컨테이너는 실행 된 OS에서 응용 프로그램 본체와 미들웨어를 실행하기 만하면되기 때문에 응용 프로그램의 시작 시간은 VM보다 크게 단축합니다.

  - 컨테이너를 실행하는 것은 OS 입장에서 보면 단순하게 프로세스를 시작하는 것이기 때문에 일반적인 프로세스가 시작하는 것과 별반 차이가 없습니다. 즉 매우 빠르게 시작할 수 있는 것입니다.

<br>

- 일관성 있는 환경

  - 개발자는 컨테이너를 이용해, 다른 애플리케이션과 분리된 애플리케이션에 최적화된 환경을 생성할 수 있습니다.

  - 컨테이너는 애플리케이션에 필요한 소프트웨어 종속 항목(프로그래밍 언어 런타임 및 기타 소프트웨어 라이브러리의 특정 버전 등)도 포함할 수 있습니다.

  - 그 결과 자연히 생산성이 향상될 수밖에 없습니다. 개발자와 IT 운영팀이 버그를 잡고 환경 차이를 진단하던 시간을 줄이고 사용자에게 신규 기능을 제공하는 데 집중할 수 있기 때문입니다.

<br>

- 다양한 운영 환경 지원

  - 컨테이너는 Linux, Windows, Mac OS, 가상 머신, 베어메탈, 개발자 PC, 데이터 센터, 온프레미스 환경, 퍼블릭 클라우드 등 사실상 어느 환경에서나 구동되므로 개발 및 배포가 크게 쉬워집니다.

  - 계층화된 이미지 형식으로 사용되기 때문에 이동성도 매우 뛰어납니다. 소프트웨어 구동 환경이 무엇이든 컨테이너를 사용할 수 있습니다.

<Br>

- 가상 OS형태로 독립환경 제공

  - 컨테이너는 CPU, 메모리, 스토리지, 네트워크 리소스를 OS 수준에서 가상화하여 개발자에게 기타 애플리케이션으로부터 논리적으로 분리된 OS 샌드박스 환경을 제공합니다.

<Br>

- 배포 편이성

  - 컨테이너를 사용하면 애플리케이션과 종속 항목을 버전 제어가 쉬운 하나의 패키지로 묶어 팀 내의 여러 개발자가 쉽게 복제하고 클러스터 내의 머신으로도 간편하게 복사할 수 있습니다.

  - 이를 서비스 기반 아키텍처와 결합하면 개발자들이 논리성을 판단해야 하는 단위 자체가 훨씬 작아지므로 민첩성과 생산성이 크게 향상됩니다. 그 결과 애플리케이션의 개발 및 테스트, 배포, 전반적인 관리가 훨씬 쉬워집니다.

<br>

### 도커(Docker)는 신기술이 아니다.

신기술도 아닌데 왜 열광할까? 라는 생각이 혹시...드시나요 ?

컨테이너라는 기술은 이미 존재했습니다.

대표적인 예가 리눅스 컨테이너(LXC)인데 여러개의 격리된 리눅스 시스템을 동작시키기 위해 사용했던 가상화 기술을 말합니다.

그 외에도 널리 알려지지 않았지만, 많은 컨테이너 기술이 존재 했습니다.

하지만 알려지지 않는데는 이유가 있죠? 복잡하고 어려워서 입니다.

하지만 도커는 기존에 있던 컨테이너라는 기술을 잘 포장하였기 때문에 진입 장벽을 무너뜨린 셈이죠. (포장의 기술)

기존 필요했던 기술을 더욱 사용하기 쉽게 포장했기 때문에 더욱 사랑 받는 이유가 아닐까요 ?

<br>

<br>

### 유튜브 정리

---

<br>

<img src="https://user-images.githubusercontent.com/62149784/180633249-3fd6ca84-10b7-4247-a6e7-659d109abe10.png">

<Br>

<img src="https://user-images.githubusercontent.com/62149784/180633246-44ce1630-62ad-45f5-859b-75e6f86f7379.png">

<Br>

<img src="https://user-images.githubusercontent.com/62149784/180633245-d1a866ff-e9ff-459c-af6a-296f1254a67f.png">

<Br>

<Br>

<img src="https://user-images.githubusercontent.com/62149784/180633242-f1da13ac-e05e-4551-85c4-97fd555b0925.png">

<Br>

### 📌도커 이미지

<br>

- 서비스에 필요한 서버, 코드, 라이브러리, 컴파일된 실행파일 등이 `포장된` 상태

<br>

즉, 특정 프로세스(IDU 프로젝트의 Node.js)를 실행하기 위해 필요한 파일과 설정값을 지닌 것.

-> 더 이상의 의존성 파일을 컴파일하거나 이것저것 설치할 필요가 없는 상태의 파일

<br>

EX) Ubuntu 이미지, MySQL 이미지

<BR>

1. 하나의 이미지는 여러 `컨테이너`를 생성할 수 있고, 컨테이너가 삭제되더라도 `이미지는 변하지 않고 그대로 남아있다.`

2. 도커 이미지들은 GitHub과 유사한 서비스인 `DockerHub를 통해 버전관리 및 배포가 가능하다`

3. 다양한 API가 제공되어 원하는 만큼 `자동화가 가능`하다.

4. `Dockerfile`이라는 파일로 이미지를 생성한다.

<BR>

### 📌 도커 컨테이너

<br>

- 이미지를 `실행한 상태`
- 각 프로세스(`컨테이너`)는 격리된 공간에서 동작된다.

<br>

1. `종료되었다고 메모리에서 삭제되지 않고 남아있다.` 삭제하려면 직접 삭제해야 한다. 때문에 컨테이너가 종료되어도 메모리에 남아있는 컨테이너를 재가동할 수 있다.

2. `컨테이너를 삭제했다는 것은 컨테이너 안에서 생성한 파일이 사라진다는 것이다.` EX) 로그를 파일로 관리한다면, 컨테이너 내에 생성된 로그 파일이 모두 사라진다는 의미이다.

3. 한 서버는 `여러 개의 컨테이너`를 가져도 상관없으며, 컨테이너는 각각 `독립적으로 실행`된다.

4. 컨테이너는 커널 공간과 호스트 OS `자원`을 `공유`한다.

<br>

출처 `https://www.44bits.io/ko/post/why-should-i-use-docker-container` <br>
출처 `https://lion-king.tistory.com/8` <br>
출처 `https://www.youtube.com/watch?v=v8UBRzhusG4`
